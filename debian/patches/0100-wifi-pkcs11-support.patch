Index: NetworkManager-0.9.10.0/libnm-util/libnm-util.ver
===================================================================
--- NetworkManager-0.9.10.0.orig/libnm-util/libnm-util.ver	2014-07-04 02:44:19.000000000 +0200
+++ NetworkManager-0.9.10.0/libnm-util/libnm-util.ver	2015-05-20 16:36:55.311611073 +0200
@@ -124,14 +124,18 @@
 	nm_setting_802_1x_get_altsubject_match;
 	nm_setting_802_1x_get_anonymous_identity;
 	nm_setting_802_1x_get_ca_cert_blob;
+	nm_setting_802_1x_get_ca_cert_id;
 	nm_setting_802_1x_get_ca_cert_path;
 	nm_setting_802_1x_get_ca_cert_scheme;
 	nm_setting_802_1x_get_ca_path;
+	nm_setting_802_1x_get_cert_id;
 	nm_setting_802_1x_get_client_cert_blob;
 	nm_setting_802_1x_get_client_cert_path;
 	nm_setting_802_1x_get_client_cert_scheme;
 	nm_setting_802_1x_get_eap_method;
+	nm_setting_802_1x_get_engine;
 	nm_setting_802_1x_get_identity;
+	nm_setting_802_1x_get_key_id;
 	nm_setting_802_1x_get_num_altsubject_matches;
 	nm_setting_802_1x_get_num_eap_methods;
 	nm_setting_802_1x_get_num_phase2_altsubject_matches;
@@ -162,6 +166,8 @@
 	nm_setting_802_1x_get_phase2_subject_match;
 	nm_setting_802_1x_get_pin;
 	nm_setting_802_1x_get_pin_flags;
+	nm_setting_802_1x_get_pkcs11_engine_path;
+	nm_setting_802_1x_get_pkcs11_module_path;
 	nm_setting_802_1x_get_private_key_blob;
 	nm_setting_802_1x_get_private_key_format;
 	nm_setting_802_1x_get_private_key_password;
Index: NetworkManager-0.9.10.0/libnm-util/nm-setting-8021x.c
===================================================================
--- NetworkManager-0.9.10.0.orig/libnm-util/nm-setting-8021x.c	2014-07-04 02:44:19.000000000 +0200
+++ NetworkManager-0.9.10.0/libnm-util/nm-setting-8021x.c	2015-05-20 16:38:13.277358684 +0200
@@ -24,6 +24,7 @@
  */
 
 #include <string.h>
+#include <sys/stat.h>
 #include <dbus/dbus-glib.h>
 #include <glib/gi18n.h>
 
@@ -125,6 +126,12 @@
 	char *phase2_private_key_password;
 	NMSettingSecretFlags phase2_private_key_password_flags;
 	gboolean system_ca_certs;
+	gboolean engine;
+	char *key_id;
+	char *cert_id;
+	char *ca_cert_id;
+	char *pkcs11_engine_path;
+	char *pkcs11_module_path;
 } NMSetting8021xPrivate;
 
 enum {
@@ -148,6 +155,8 @@
 	PROP_PHASE2_SUBJECT_MATCH,
 	PROP_PHASE2_ALTSUBJECT_MATCHES,
 	PROP_PHASE2_CLIENT_CERT,
+	PROP_PIN,
+	PROP_PIN_FLAGS,
 	PROP_PASSWORD,
 	PROP_PASSWORD_FLAGS,
 	PROP_PASSWORD_RAW,
@@ -158,9 +167,13 @@
 	PROP_PHASE2_PRIVATE_KEY,
 	PROP_PHASE2_PRIVATE_KEY_PASSWORD,
 	PROP_PHASE2_PRIVATE_KEY_PASSWORD_FLAGS,
-	PROP_PIN,
-	PROP_PIN_FLAGS,
 	PROP_SYSTEM_CA_CERTS,
+	PROP_ENGINE,
+	PROP_KEY_ID,
+	PROP_CERT_ID,
+	PROP_CA_CERT_ID,
+	PROP_PKCS11_ENGINE_PATH,
+	PROP_PKCS11_MODULE_PATH,
 
 	LAST_PROP
 };
@@ -1600,7 +1613,7 @@
 NMSettingSecretFlags
 nm_setting_802_1x_get_pin_flags (NMSetting8021x *setting)
 {
-	g_return_val_if_fail (NM_IS_SETTING_802_1X (setting), NM_SETTING_SECRET_FLAG_NONE);
+	g_return_val_if_fail (NM_IS_SETTING_802_1X (setting), NM_SETTING_SECRET_FLAG_NOT_REQUIRED);
 
 	return NM_SETTING_802_1X_GET_PRIVATE (setting)->pin_flags;
 }
@@ -2181,6 +2194,107 @@
 	return NM_SETTING_802_1X_CK_FORMAT_UNKNOWN;
 }
 
+/**
+ * nm_setting_802_1x_get_engine:
+ * @setting: The #NMSetting8021x
+ *
+ * Gets the #NMSetting8021x:engine property.
+ *
+ * Returns: TRUE if the OpenSSL engine should be used, FALSE if not
+ **/
+gboolean
+nm_setting_802_1x_get_engine (NMSetting8021x *setting)
+{
+	g_return_val_if_fail (NM_IS_SETTING_802_1X (setting), FALSE);
+
+	return NM_SETTING_802_1X_GET_PRIVATE (setting)->engine;
+}
+
+/**
+ * nm_setting_802_1x_get_key_id:
+ * @setting: the #NMSetting8021x
+ *
+ * Gets the #NMSetting8021x:key-id property.
+ *
+ * Returns: Key identifier for the OpenSSL engine to use if
+ * #NMSetting8021x:engine is set to TRUE
+ **/
+const char *
+nm_setting_802_1x_get_key_id (NMSetting8021x *setting)
+{
+	g_return_val_if_fail (NM_IS_SETTING_802_1X (setting), NULL);
+
+	return (const char *) (NM_SETTING_802_1X_GET_PRIVATE (setting)->key_id);
+}
+
+/**
+ * nm_setting_802_1x_get_cert_id:
+ * @setting: the #NMSetting8021x
+ *
+ * Gets the #NMSetting8021x:cert-id property.
+ *
+ * Returns: Certificate identifier for the OpenSSL engine to use if
+ * #NMSetting8021x:engine is set to TRUE
+ **/
+const char *
+nm_setting_802_1x_get_cert_id (NMSetting8021x *setting)
+{
+	g_return_val_if_fail (NM_IS_SETTING_802_1X (setting), NULL);
+
+	return (const char *) (NM_SETTING_802_1X_GET_PRIVATE (setting)->cert_id);
+}
+
+/**
+ * nm_setting_802_1x_get_ca_cert_id:
+ * @setting: the #NMSetting8021x
+ *
+ * Gets the #NMSetting8021x:ca-cert-id property.
+ *
+ * Returns: CA certificate identifier for the OpenSSL engine to use if
+ * #NMSetting8021x:engine is set to TRUE
+ **/
+const char *
+nm_setting_802_1x_get_ca_cert_id (NMSetting8021x *setting)
+{
+	g_return_val_if_fail (NM_IS_SETTING_802_1X (setting), NULL);
+
+	return (const char *) (NM_SETTING_802_1X_GET_PRIVATE (setting)->ca_cert_id);
+}
+
+/**
+ * nm_setting_802_1x_get_pkcs11_engine_path:
+ * @setting: the #NMSetting8021x
+ *
+ * Gets the #NMSetting8021x:pkcs11-engine-path property.
+ *
+ * Returns: PKCS #11 engine path for the OpenSSL engine to use if
+ * #NMSetting8021x:engine or #NMSetting8021x:phase2-engine is set to TRUE
+ **/
+const char *
+nm_setting_802_1x_get_pkcs11_engine_path (NMSetting8021x *setting)
+{
+	g_return_val_if_fail (NM_IS_SETTING_802_1X (setting), NULL);
+
+	return (const char *) (NM_SETTING_802_1X_GET_PRIVATE (setting)->pkcs11_engine_path);
+}
+
+/**
+ * nm_setting_802_1x_get_pkcs11_module_path:
+ * @setting: the #NMSetting8021x
+ *
+ * Gets the #NMSetting8021x:pkcs11-module-path property.
+ *
+ * Returns: PKCS #11 module path for the OpenSSL engine to use if
+ * #NMSetting8021x:engine or #NMSetting8021x:phase2-engine is set to TRUE
+ **/
+const char *
+nm_setting_802_1x_get_pkcs11_module_path (NMSetting8021x *setting)
+{
+	g_return_val_if_fail (NM_IS_SETTING_802_1X (setting), NULL);
+
+	return (const char *) (NM_SETTING_802_1X_GET_PRIVATE (setting)->pkcs11_module_path);
+}
+
 static void
 need_secrets_password (NMSetting8021x *self,
                        GPtrArray *secrets,
@@ -2202,6 +2316,7 @@
 {
 	NMSetting8021xPrivate *priv = NM_SETTING_802_1X_GET_PRIVATE (self);
 
+	/* The PIN is mandatory for EAP-SIM */
 	if (!priv->pin || !strlen (priv->pin))
 		g_ptr_array_add (secrets, NM_SETTING_802_1X_PIN);
 }
@@ -2251,19 +2366,29 @@
 		if (need_private_key_password (blob, path, priv->phase2_private_key_password))
 			g_ptr_array_add (secrets, NM_SETTING_802_1X_PHASE2_PRIVATE_KEY_PASSWORD);
 	} else {
-		scheme = nm_setting_802_1x_get_private_key_scheme (self);
-		if (scheme == NM_SETTING_802_1X_CK_SCHEME_PATH)
-			path = nm_setting_802_1x_get_private_key_path (self);
-		else if (scheme == NM_SETTING_802_1X_CK_SCHEME_BLOB)
-			blob = nm_setting_802_1x_get_private_key_blob (self);
-		else {
-			g_warning ("%s: unknown private key scheme %d", __func__, scheme);
-			g_ptr_array_add (secrets, NM_SETTING_802_1X_PRIVATE_KEY);
-			return;
-		}
+		if (priv->engine) {
+			/* If the PKCS #11 OpenSSL engine is active the PIN might be a
+			 * secret. By default the PIN is optional but if it has been
+			 * specified it is a required secret. In case of errors check
+			 * the ENGINE lines in the log/output of the WPA supplicant. */
+			if (!(priv->pin_flags & NM_SETTING_SECRET_FLAG_NOT_REQUIRED))
+				if (!priv->pin || !strlen (priv->pin))
+					g_ptr_array_add (secrets, NM_SETTING_802_1X_PIN);
+		} else {
+			scheme = nm_setting_802_1x_get_private_key_scheme (self);
+			if (scheme == NM_SETTING_802_1X_CK_SCHEME_PATH)
+				path = nm_setting_802_1x_get_private_key_path (self);
+			else if (scheme == NM_SETTING_802_1X_CK_SCHEME_BLOB)
+				blob = nm_setting_802_1x_get_private_key_blob (self);
+			else {
+				g_warning ("%s: unknown private key scheme %d", __func__, scheme);
+				g_ptr_array_add (secrets, NM_SETTING_802_1X_PRIVATE_KEY);
+				return;
+			}
 
-		if (need_private_key_password (blob, path, priv->private_key_password))
-			g_ptr_array_add (secrets, NM_SETTING_802_1X_PRIVATE_KEY_PASSWORD);
+			if (need_private_key_password (blob, path, priv->private_key_password))
+				g_ptr_array_add (secrets, NM_SETTING_802_1X_PRIVATE_KEY_PASSWORD);
+		}
 	}
 }
 
@@ -2331,62 +2456,73 @@
 			}
 		}
 	} else {
-		if (!priv->client_cert) {
-			g_set_error_literal (error,
-			                     NM_SETTING_802_1X_ERROR,
-			                     NM_SETTING_802_1X_ERROR_MISSING_PROPERTY,
-			                     _("property is missing"));
-			g_prefix_error (error, "%s.%s: ", NM_SETTING_802_1X_SETTING_NAME, NM_SETTING_802_1X_CLIENT_CERT);
-			return FALSE;
-		} else if (!priv->client_cert->len) {
-			g_set_error_literal (error,
-			                     NM_SETTING_802_1X_ERROR,
-			                     NM_SETTING_802_1X_ERROR_INVALID_PROPERTY,
-			                     _("property is empty"));
-			g_prefix_error (error, "%s.%s: ", NM_SETTING_802_1X_SETTING_NAME, NM_SETTING_802_1X_CLIENT_CERT);
-			return FALSE;
-		}
-
-		/* Private key is required for TLS */
-		if (!priv->private_key) {
-			g_set_error_literal (error,
-			                     NM_SETTING_802_1X_ERROR,
-			                     NM_SETTING_802_1X_ERROR_MISSING_PROPERTY,
-			                     _("property is missing"));
-			g_prefix_error (error, "%s.%s: ", NM_SETTING_802_1X_SETTING_NAME, NM_SETTING_802_1X_PRIVATE_KEY);
-			return FALSE;
-		} else if (!priv->private_key->len) {
-			g_set_error_literal (error,
-			                     NM_SETTING_802_1X_ERROR,
-			                     NM_SETTING_802_1X_ERROR_INVALID_PROPERTY,
-			                     _("property is empty"));
-			g_prefix_error (error, "%s.%s: ", NM_SETTING_802_1X_SETTING_NAME, NM_SETTING_802_1X_PRIVATE_KEY);
-			return FALSE;
-		}
-
-		/* If the private key is PKCS#12, check that it matches the client cert */
-		if (crypto_is_pkcs12_data (priv->private_key)) {
-			if (priv->private_key->len != priv->client_cert->len) {
-				g_set_error (error,
+		/* If the PKCS #11 OpenSSL engine is active, the required configuration
+		 * options - if any - depend on the active PKCS #11 module. Because of
+		 * this it is unknown which configuration options are required. In case
+		 * of errors the ENGINE lines in the log/output of the WPA supplicant
+		 * need to be consulted for missing or faulty configuration options. */
+		if (!priv->engine) {
+			if (!priv->client_cert) {
+ 				g_set_error (error,
 				             NM_SETTING_802_1X_ERROR,
-				             NM_SETTING_802_1X_ERROR_INVALID_PROPERTY,
+				             NM_SETTING_802_1X_ERROR_MISSING_PROPERTY,
 				             _("has to match '%s' property for PKCS#12"),
-				             NM_SETTING_802_1X_PRIVATE_KEY);
+				             NM_SETTING_802_1X_CLIENT_CERT);
+				g_prefix_error (error, "%s.%s: ", NM_SETTING_802_1X_SETTING_NAME, NM_SETTING_802_1X_CLIENT_CERT);
+				return FALSE;
+			} else if (!priv->client_cert->len) {
+				g_set_error (error,
+							 NM_SETTING_802_1X_ERROR,
+							 NM_SETTING_802_1X_ERROR_INVALID_PROPERTY,
+							 _("has to match '%s' property for PKCS#12"),
+							 NM_SETTING_802_1X_CLIENT_CERT);
 				g_prefix_error (error, "%s.%s: ", NM_SETTING_802_1X_SETTING_NAME, NM_SETTING_802_1X_CLIENT_CERT);
 				return FALSE;
 			}
 
-			if (memcmp (priv->private_key->data,
-			            priv->client_cert->data,
-			            priv->private_key->len)) {
+			/* Private key is required for TLS */
+			if (!priv->private_key) {
 				g_set_error (error,
 				             NM_SETTING_802_1X_ERROR,
-				             NM_SETTING_802_1X_ERROR_INVALID_PROPERTY,
+				             NM_SETTING_802_1X_ERROR_MISSING_PROPERTY,
 				             _("has to match '%s' property for PKCS#12"),
 				             NM_SETTING_802_1X_PRIVATE_KEY);
-				g_prefix_error (error, "%s.%s: ", NM_SETTING_802_1X_SETTING_NAME, NM_SETTING_802_1X_CLIENT_CERT);
+				g_prefix_error (error, "%s.%s: ", NM_SETTING_802_1X_SETTING_NAME, NM_SETTING_802_1X_PRIVATE_KEY);
+				return FALSE;
+			} else if (!priv->private_key->len) {
+				g_set_error (error,
+							 NM_SETTING_802_1X_ERROR,
+							 NM_SETTING_802_1X_ERROR_INVALID_PROPERTY,
+				             _("has to match '%s' property for PKCS#12"),
+							 NM_SETTING_802_1X_PRIVATE_KEY);
+				g_prefix_error (error, "%s.%s: ", NM_SETTING_802_1X_SETTING_NAME, NM_SETTING_802_1X_PRIVATE_KEY);
 				return FALSE;
 			}
+
+			/* If the private key is PKCS#12, check that it matches the client cert */
+			if (crypto_is_pkcs12_data (priv->private_key)) {
+				if (priv->private_key->len != priv->client_cert->len) {
+					g_set_error (error,
+								 NM_SETTING_802_1X_ERROR,
+								 NM_SETTING_802_1X_ERROR_INVALID_PROPERTY,
+				             	 _("has to match '%s' property for PKCS#12"),
+								 NM_SETTING_802_1X_CLIENT_CERT);
+					g_prefix_error (error, "%s.%s: ", NM_SETTING_802_1X_SETTING_NAME, NM_SETTING_802_1X_CLIENT_CERT);
+					return FALSE;
+				}
+
+				if (memcmp (priv->private_key->data,
+							priv->client_cert->data,
+							priv->private_key->len)) {
+					g_set_error (error,
+								 NM_SETTING_802_1X_ERROR,
+								 NM_SETTING_802_1X_ERROR_INVALID_PROPERTY,
+				             	 _("has to match '%s' property for PKCS#12"),
+								 NM_SETTING_802_1X_CLIENT_CERT);
+					g_prefix_error (error, "%s.%s: ", NM_SETTING_802_1X_SETTING_NAME, NM_SETTING_802_1X_CLIENT_CERT);
+					return FALSE;
+				}
+			}
 		}
 	}
 
@@ -2634,12 +2770,14 @@
 	NMSetting8021x *self = NM_SETTING_802_1X (setting);
 	NMSetting8021xPrivate *priv = NM_SETTING_802_1X_GET_PRIVATE (self);
 	const char *valid_eap[] = { "leap", "md5", "tls", "peap", "ttls", "sim", "fast", "pwd", NULL };
+	const char *valid_eap_engine[] = { "tls", NULL };  // In case the PKCS #11 OpenSSL engine is in use only EAP-TLS is allowed
 	const char *valid_phase1_peapver[] = { "0", "1", NULL };
 	const char *valid_phase1_peaplabel[] = { "0", "1", NULL };
 	const char *valid_phase1_fast_pac[] = { "0", "1", "2", "3", NULL };
 	const char *valid_phase2_auth[] = { "pap", "chap", "mschap", "mschapv2", "gtc", "otp", "md5", "tls", NULL };
 	const char *valid_phase2_autheap[] = { "md5", "mschapv2", "otp", "gtc", "tls", NULL };
 	GSList *iter;
+	struct stat info_module, info_engine;
 
 	if (error)
 		g_return_val_if_fail (*error == NULL, FALSE);
@@ -2653,13 +2791,22 @@
 		return FALSE;
 	}
 
-	if (!_nm_utils_string_slist_validate (priv->eap, valid_eap)) {
-		g_set_error_literal (error,
-		                     NM_SETTING_802_1X_ERROR,
-		                     NM_SETTING_802_1X_ERROR_INVALID_PROPERTY,
-		                     _("property is invalid"));
-		g_prefix_error (error, "%s.%s: ", NM_SETTING_802_1X_SETTING_NAME, NM_SETTING_802_1X_EAP);
-		return FALSE;
+	if (priv->engine) {
+		if (!_nm_utils_string_slist_validate (priv->eap, valid_eap_engine)) {
+			g_set_error (error,
+						 NM_SETTING_802_1X_ERROR,
+						 NM_SETTING_802_1X_ERROR_INVALID_PROPERTY,
+						 _("property is invalid"));
+			return FALSE;
+		}
+	} else {
+		if (!_nm_utils_string_slist_validate (priv->eap, valid_eap)) {
+			g_set_error (error,
+						 NM_SETTING_802_1X_ERROR,
+						 NM_SETTING_802_1X_ERROR_INVALID_PROPERTY,
+						 _("property is invalid"));
+			return FALSE;
+		}
 	}
 
 	/* Ask each configured EAP method if its valid */
@@ -2728,6 +2875,19 @@
 		return FALSE;
 	}
 
+	if (priv->engine) {
+		/* PKCS #11 OpenSSL engine is enabled.
+		 * The private key gets handled via the PKCS #11 OpenSSL engine and
+		 * thus it needs to be absent. */
+		if (priv->private_key) {
+			g_set_error (error,
+						 NM_SETTING_802_1X_ERROR,
+						 NM_SETTING_802_1X_ERROR_INVALID_PROPERTY,
+						 NM_SETTING_802_1X_EAP);
+			return FALSE;
+		}
+	}
+
 	if (!verify_cert (priv->ca_cert, NM_SETTING_802_1X_CA_CERT, error))
 		return FALSE;
 	if (!verify_cert (priv->phase2_ca_cert, NM_SETTING_802_1X_PHASE2_CA_CERT, error))
@@ -2743,6 +2903,77 @@
 	if (!verify_cert (priv->phase2_private_key, NM_SETTING_802_1X_PHASE2_PRIVATE_KEY, error))
 		return FALSE;
 
+	if (priv->engine) {
+		/* If the PKCS #11 OpenSSL engine is active, the required configuration
+		 * options - if any - depend on the active PKCS #11 module. Because of
+		 * this it is unknown which configuration options are required. In case
+		 * of errors the ENGINE lines in the log/output of the WPA supplicant
+		 * need to be consulted for missing or faulty configuration options. */
+
+		/* Check PKCS #11 engine and module path if specified */
+		if (priv->pkcs11_engine_path || priv->pkcs11_module_path) {
+			/* Both engine and module bath need to be given */
+			if (!priv->pkcs11_engine_path) {
+				g_set_error (error,
+							 NM_SETTING_802_1X_ERROR,
+							 NM_SETTING_802_1X_ERROR_MISSING_PROPERTY,
+							 NM_SETTING_802_1X_EAP);
+				return FALSE;
+			}
+			if (!priv->pkcs11_module_path) {
+				g_set_error (error,
+							 NM_SETTING_802_1X_ERROR,
+							 NM_SETTING_802_1X_ERROR_MISSING_PROPERTY,
+							 NM_SETTING_802_1X_EAP);
+				return FALSE;
+			}
+
+			/* Engine and module path are not allowed to be an empty string */
+			if (!strlen(priv->pkcs11_engine_path)) {
+				g_set_error (error,
+							 NM_SETTING_802_1X_ERROR,
+							 NM_SETTING_802_1X_ERROR_INVALID_PROPERTY,
+							 NM_SETTING_802_1X_EAP);
+				return FALSE;
+			}
+			if (!strlen(priv->pkcs11_module_path)) {
+				g_set_error (error,
+							 NM_SETTING_802_1X_ERROR,
+							 NM_SETTING_802_1X_ERROR_INVALID_PROPERTY,
+							 NM_SETTING_802_1X_EAP);
+				return FALSE;
+			}
+			/* Check that the engine and the module are within an allowed filesystem prefix */
+			#define PKCS11_ALLOWED_PREFIX "/usr/lib/"
+			if (strncmp(priv->pkcs11_engine_path, PKCS11_ALLOWED_PREFIX, strlen(PKCS11_ALLOWED_PREFIX)) != 0 ||
+				strncmp(priv->pkcs11_module_path, PKCS11_ALLOWED_PREFIX, strlen(PKCS11_ALLOWED_PREFIX)) != 0) {
+				g_warning ("pkcs11_engine_path and pkcs11_module_path must be in "PKCS11_ALLOWED_PREFIX);
+				g_set_error (error,
+							 NM_SETTING_802_1X_ERROR,
+							 NM_SETTING_802_1X_ERROR_INVALID_PROPERTY,
+							 NM_SETTING_802_1X_EAP);
+				return FALSE;
+			}
+			/* Check that the engine and the module files are owned by root */
+			if (stat(priv->pkcs11_engine_path, &info_engine) != 0) {
+				g_warning ("can't stat() on pkcs11_engine_path");
+				return FALSE;
+			}
+			if (stat(priv->pkcs11_module_path, &info_module) != 0) {
+				g_warning ("can't stat() on pkcs11_module_path");
+				return FALSE;
+			}
+			if (info_engine.st_uid != 0 || info_module.st_uid) {
+				g_warning ("pkcs11_engine_path and pkcs11_module_path must be files owned by root");
+				g_set_error (error,
+							 NM_SETTING_802_1X_ERROR,
+							 NM_SETTING_802_1X_ERROR_INVALID_PROPERTY,
+							 NM_SETTING_802_1X_EAP);
+				return FALSE;
+			}
+		}
+	}
+
 	/* FIXME: finish */
 
 	return TRUE;
@@ -2990,6 +3221,11 @@
 	case PROP_PIN:
 		g_free (priv->pin);
 		priv->pin = g_value_dup_string (value);
+		if (priv->pin) {
+			/* PIN has been set and is required from now on. Ensure that the
+			 * NM_SETTING_SECRET_FLAG_NOT_REQUIRED bit is not set in the flags. */
+			priv->pin_flags &= ~NM_SETTING_SECRET_FLAG_NOT_REQUIRED;
+		}
 		break;
 	case PROP_PIN_FLAGS:
 		priv->pin_flags = g_value_get_uint (value);
@@ -2997,6 +3233,29 @@
 	case PROP_SYSTEM_CA_CERTS:
 		priv->system_ca_certs = g_value_get_boolean (value);
 		break;
+	case PROP_ENGINE:
+		priv->engine = g_value_get_boolean (value);
+		break;
+	case PROP_KEY_ID:
+		g_free (priv->key_id);
+		priv->key_id = g_value_dup_string (value);
+		break;
+	case PROP_CERT_ID:
+		g_free (priv->cert_id);
+		priv->cert_id = g_value_dup_string (value);
+		break;
+	case PROP_CA_CERT_ID:
+		g_free (priv->ca_cert_id);
+		priv->ca_cert_id = g_value_dup_string (value);
+		break;
+	case PROP_PKCS11_ENGINE_PATH:
+		g_free (priv->pkcs11_engine_path);
+		priv->pkcs11_engine_path = g_value_dup_string (value);
+		break;
+	case PROP_PKCS11_MODULE_PATH:
+		g_free (priv->pkcs11_module_path);
+		priv->pkcs11_module_path = g_value_dup_string (value);
+		break;
 	default:
 		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 		break;
@@ -3099,14 +3358,32 @@
 		g_value_set_uint (value, priv->phase2_private_key_password_flags);
 		break;
 	case PROP_PIN:
-		g_value_set_string (value, priv->pin);
+		g_value_set_string (value, nm_setting_802_1x_get_pin (setting));
 		break;
 	case PROP_PIN_FLAGS:
-		g_value_set_uint (value, priv->pin_flags);
+		g_value_set_uint (value, nm_setting_802_1x_get_pin_flags (setting));
 		break;
 	case PROP_SYSTEM_CA_CERTS:
 		g_value_set_boolean (value, priv->system_ca_certs);
 		break;
+	case PROP_ENGINE:
+		g_value_set_boolean (value, nm_setting_802_1x_get_engine (setting));
+		break;
+	case PROP_KEY_ID:
+		g_value_set_string (value, nm_setting_802_1x_get_key_id (setting));
+		break;
+	case PROP_CERT_ID:
+		g_value_set_string (value, nm_setting_802_1x_get_cert_id (setting));
+		break;
+	case PROP_CA_CERT_ID:
+		g_value_set_string (value, nm_setting_802_1x_get_ca_cert_id (setting));
+		break;
+	case PROP_PKCS11_ENGINE_PATH:
+		g_value_set_string (value, nm_setting_802_1x_get_pkcs11_engine_path (setting));
+		break;
+	case PROP_PKCS11_MODULE_PATH:
+		g_value_set_string (value, nm_setting_802_1x_get_pkcs11_module_path (setting));
+		break;
 	default:
 		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 		break;
@@ -3853,10 +4130,13 @@
 	g_object_class_install_property
 		(object_class, PROP_PIN,
 		 g_param_spec_string (NM_SETTING_802_1X_PIN,
-		                      "PIN",
-		                      "PIN used for EAP authentication methods.",
-		                      NULL,
-		                      G_PARAM_READWRITE | NM_SETTING_PARAM_SECRET));
+					  "PIN for USIM, GSM SIM, and smartcards",
+					  "This field is used to configure PIN for SIM "
+					  "and smartcards for EAP-SIM and EAP-AKA. In "
+					  "addition, this is used with EAP-TLS if a "
+					  "smartcard is used for private key operations.",
+							  NULL,
+							  G_PARAM_READWRITE | NM_SETTING_PARAM_SERIALIZE | NM_SETTING_PARAM_SECRET));
 
 	/**
 	 * NMSetting8021x:pin-flags:
@@ -3865,12 +4145,12 @@
 	 **/
 	g_object_class_install_property (object_class, PROP_PIN_FLAGS,
 		 g_param_spec_uint (NM_SETTING_802_1X_PIN_FLAGS,
-		                    "PIN Flags",
-		                    "Flags indicating how to handle the 802.1x PIN.",
-		                    NM_SETTING_SECRET_FLAG_NONE,
-		                    NM_SETTING_SECRET_FLAGS_ALL,
-		                    NM_SETTING_SECRET_FLAG_NONE,
-		                    G_PARAM_READWRITE));
+							"PIN Flags",
+							"Flags indicating how to handle the 802.1x PIN.",
+							NM_SETTING_SECRET_FLAG_NONE,
+							NM_SETTING_SECRET_FLAGS_ALL,
+							NM_SETTING_SECRET_FLAG_NOT_REQUIRED,
+							G_PARAM_READWRITE | G_PARAM_CONSTRUCT | NM_SETTING_PARAM_SERIALIZE));
 
 	/**
 	 * NMSetting8021x:system-ca-certs:
@@ -3896,6 +4176,105 @@
 							   FALSE,
 							   G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
 
+	/**
+	 * NMSetting8021x:engine:
+	 *
+	 * When TRUE, the PKCS #11 OpenSSL engine will be used. E.g. this is needed
+	 * if private key operations for EAP-TLS will be performed on a smartcard.
+	 **/
+	g_object_class_install_property
+		(object_class, PROP_ENGINE,
+		 g_param_spec_boolean (NM_SETTING_802_1X_ENGINE,
+							   "Use PKCS #11 OpenSSL engine",
+							   "When TRUE, the PKCS #11 OpenSSL engine will "
+							   "be used. E.g. this is needed if private key "
+							   "operations for EAP-TLS will be performed on a "
+							   "smartcard.",
+							   FALSE,
+							   G_PARAM_READWRITE | G_PARAM_CONSTRUCT | NM_SETTING_PARAM_SERIALIZE));
+
+	/**
+	 * NMSetting8021x:key-id:
+	 *
+	 * Key identifier for the PKCS #11 OpenSSL engine to use if
+	 * #NMSetting8021x:engine is set to TRUE
+	 **/
+	g_object_class_install_property
+		(object_class, PROP_KEY_ID,
+		 g_param_spec_string (NM_SETTING_802_1X_KEY_ID,
+							  "Key ID for PKCS #11 OpenSSL engine",
+							  "The key identifier to use for the PKCS #11 "
+							  "OpenSSL engine. This is used if private key "
+							  "operations for EAP-TLS are performed using a "
+							  "smartcard.",
+							  NULL,
+							  G_PARAM_READWRITE | NM_SETTING_PARAM_SERIALIZE));
+
+	/**
+	 * NMSetting8021x:cert-id:
+	 *
+	 * Certificate identifier for the PKCS #11 OpenSSL engine to use if
+	 * #NMSetting8021x:engine is set to TRUE
+	 **/
+	g_object_class_install_property
+		(object_class, PROP_CERT_ID,
+		 g_param_spec_string (NM_SETTING_802_1X_CERT_ID,
+							  "Cert ID for PKCS #11 OpenSSL engine",
+							  "The certificate identifier to use for the "
+							  "PKCS #11 OpenSSL engine. This is used if "
+							  "private key operations for EAP-TLS are "
+							  "performed using a smartcard.",
+							  NULL,
+							  G_PARAM_READWRITE | NM_SETTING_PARAM_SERIALIZE));
+
+	/**
+	 * NMSetting8021x:ca-cert-id:
+	 *
+	 * CA certificate identifier for the PKCS #11 OpenSSL engine to use if
+	 * #NMSetting8021x:engine is set to TRUE
+	 **/
+	g_object_class_install_property
+		(object_class, PROP_CA_CERT_ID,
+		 g_param_spec_string (NM_SETTING_802_1X_CA_CERT_ID,
+							  "CA Cert ID for PKCS #11 OpenSSL engine",
+							  "The CA certificate identifier to use for the "
+							  "PKCS #11 OpenSSL engine. This is used if "
+							  "private key operations for EAP-TLS are "
+							  "performed using a smartcard.",
+							  NULL,
+							  G_PARAM_READWRITE | NM_SETTING_PARAM_SERIALIZE));
+
+	/**
+	 * NMSetting8021x:pkcs11-engine-path:
+	 *
+	 * PKCS #11 engine path for the OpenSSL engine to use if
+	 * #NMSetting8021x:engine or #NMSetting8021x:phase2-engine is set to TRUE.
+	 **/
+	g_object_class_install_property
+		(object_class, PROP_PKCS11_ENGINE_PATH,
+		 g_param_spec_string (NM_SETTING_802_1X_PKCS11_ENGINE_PATH,
+							  "PKCS #11 Engine Path",
+							  "The PKCS #11 engine path to use if the "
+							  "PKCS #11 OpenSSL engine is in use. "
+							  "Usually path to engine_pkcs11.so.",
+							  NULL,
+							  G_PARAM_READWRITE | NM_SETTING_PARAM_SERIALIZE));
+
+	/**
+	 * NMSetting8021x:pkcs11-module-path:
+	 *
+	 * PKCS #11 module path for the OpenSSL engine to use if
+	 * #NMSetting8021x:engine or #NMSetting8021x:phase2-engine is set to TRUE.
+	 **/
+	g_object_class_install_property
+		(object_class, PROP_PKCS11_MODULE_PATH,
+		 g_param_spec_string (NM_SETTING_802_1X_PKCS11_MODULE_PATH,
+							  "PKCS #11 Module Path",
+							  "The PKCS #11 module path to use if the "
+							  "PKCS #11 OpenSSL engine is in use.",
+							  NULL,
+							  G_PARAM_READWRITE | NM_SETTING_PARAM_SERIALIZE));
+
 	/* Initialize crypto lbrary. */
 	if (!nm_utils_init (&error)) {
 		g_warning ("Couldn't initilize nm-utils/crypto system: %d %s",
Index: NetworkManager-0.9.10.0/libnm-util/nm-setting-8021x.h
===================================================================
--- NetworkManager-0.9.10.0.orig/libnm-util/nm-setting-8021x.h	2014-07-04 02:44:13.000000000 +0200
+++ NetworkManager-0.9.10.0/libnm-util/nm-setting-8021x.h	2015-05-20 16:36:55.315611163 +0200
@@ -127,6 +127,12 @@
 #define NM_SETTING_802_1X_PIN "pin"
 #define NM_SETTING_802_1X_PIN_FLAGS "pin-flags"
 #define NM_SETTING_802_1X_SYSTEM_CA_CERTS "system-ca-certs"
+#define NM_SETTING_802_1X_ENGINE "engine"
+#define NM_SETTING_802_1X_KEY_ID "key-id"
+#define NM_SETTING_802_1X_CERT_ID "cert-id"
+#define NM_SETTING_802_1X_CA_CERT_ID "ca-cert-id"
+#define NM_SETTING_802_1X_PKCS11_ENGINE_PATH "pkcs11-engine-path"
+#define NM_SETTING_802_1X_PKCS11_MODULE_PATH "pkcs11-module-path"
 
 /* PRIVATE KEY NOTE: when setting PKCS#12 private keys directly via properties
  * using the "blob" scheme, the data must be passed in PKCS#12 binary format.
@@ -146,6 +152,10 @@
  *
  * When using the "path" scheme, just set the private-key and client-cert
  * properties to the paths to their respective objects.
+ *
+ * Do not set a private key when using the PKCS #11 OpenSSL engine. Depending
+ * on the active PKCS #11 module, the "key-id" property might be required to
+ * specify which private key to use.
  */
 
 typedef struct {
@@ -294,6 +304,13 @@
 
 NMSetting8021xCKFormat nm_setting_802_1x_get_phase2_private_key_format   (NMSetting8021x *setting);
 
+gboolean          nm_setting_802_1x_get_engine                       (NMSetting8021x *setting);
+const char *      nm_setting_802_1x_get_key_id                       (NMSetting8021x *setting);
+const char *      nm_setting_802_1x_get_cert_id                      (NMSetting8021x *setting);
+const char *      nm_setting_802_1x_get_ca_cert_id                   (NMSetting8021x *setting);
+const char *      nm_setting_802_1x_get_pkcs11_engine_path           (NMSetting8021x *setting);
+const char *      nm_setting_802_1x_get_pkcs11_module_path           (NMSetting8021x *setting);
+
 
 G_END_DECLS
 
Index: NetworkManager-0.9.10.0/src/supplicant-manager/nm-supplicant-config.c
===================================================================
--- NetworkManager-0.9.10.0.orig/src/supplicant-manager/nm-supplicant-config.c	2014-07-04 02:44:13.000000000 +0200
+++ NetworkManager-0.9.10.0/src/supplicant-manager/nm-supplicant-config.c	2015-05-20 16:36:55.315611163 +0200
@@ -52,6 +52,8 @@
 {
 	GHashTable *config;
 	GHashTable *blobs;
+	char       *pkcs11_engine_path;
+	char       *pkcs11_module_path;
 	guint32    ap_scan;
 	gboolean   fast_required;
 	gboolean   dispose_has_run;
@@ -89,6 +91,8 @@
 	                                     (GDestroyNotify) g_free,
 	                                     (GDestroyNotify) blob_free);
 
+	priv->pkcs11_engine_path = NULL;
+	priv->pkcs11_module_path = NULL;
 	priv->ap_scan = 1;
 	priv->dispose_has_run = FALSE;
 }
@@ -214,9 +218,13 @@
 static void
 nm_supplicant_config_finalize (GObject *object)
 {
+	NMSupplicantConfigPrivate *priv = NM_SUPPLICANT_CONFIG_GET_PRIVATE (object);
+
 	/* Complete object destruction */
-	g_hash_table_destroy (NM_SUPPLICANT_CONFIG_GET_PRIVATE (object)->config);
-	g_hash_table_destroy (NM_SUPPLICANT_CONFIG_GET_PRIVATE (object)->blobs);
+	g_hash_table_destroy (priv->config);
+	g_hash_table_destroy (priv->blobs);
+	g_free (priv->pkcs11_engine_path);
+	g_free (priv->pkcs11_module_path);
 
 	/* Chain up to the parent class */
 	G_OBJECT_CLASS (nm_supplicant_config_parent_class)->finalize (object);
@@ -233,6 +241,48 @@
 	g_type_class_add_private (object_class, sizeof (NMSupplicantConfigPrivate));
 }
 
+const char *
+nm_supplicant_config_get_pkcs11_engine_path (NMSupplicantConfig * self)
+{
+	g_return_val_if_fail (NM_IS_SUPPLICANT_CONFIG (self), NULL);
+
+	return NM_SUPPLICANT_CONFIG_GET_PRIVATE (self)->pkcs11_engine_path;
+}
+
+void
+nm_supplicant_config_set_pkcs11_engine_path (NMSupplicantConfig * self,
+											 const char *pkcs11_engine_path)
+{
+	NMSupplicantConfigPrivate *priv;
+
+	g_return_if_fail (NM_IS_SUPPLICANT_CONFIG (self));
+
+	priv = NM_SUPPLICANT_CONFIG_GET_PRIVATE (self);
+	g_free (priv->pkcs11_engine_path);
+	priv->pkcs11_engine_path = g_strdup (pkcs11_engine_path);
+}
+
+const char *
+nm_supplicant_config_get_pkcs11_module_path (NMSupplicantConfig * self)
+{
+	g_return_val_if_fail (NM_IS_SUPPLICANT_CONFIG (self), NULL);
+
+	return NM_SUPPLICANT_CONFIG_GET_PRIVATE (self)->pkcs11_module_path;
+}
+
+void
+nm_supplicant_config_set_pkcs11_module_path (NMSupplicantConfig * self,
+											 const char *pkcs11_module_path)
+{
+	NMSupplicantConfigPrivate *priv;
+
+	g_return_if_fail (NM_IS_SUPPLICANT_CONFIG (self));
+
+	priv = NM_SUPPLICANT_CONFIG_GET_PRIVATE (self);
+	g_free (priv->pkcs11_module_path);
+	priv->pkcs11_module_path = g_strdup (pkcs11_module_path);
+}
+
 guint32
 nm_supplicant_config_get_ap_scan (NMSupplicantConfig * self)
 {
@@ -1052,6 +1102,72 @@
 	if (!add_string_val (self, value, "anonymous_identity", FALSE, FALSE))
 		return FALSE;
 
+	/**
+	 * PKCS #11 OpenSSL engine:
+	 * For a description of the fields see the eap_config and eap_peer_config
+	 * struct reference of wpa_supplicant:
+	 * http://hostap.epitest.fi/wpa_supplicant/devel/structeap__config.html
+	 * http://hostap.epitest.fi/wpa_supplicant/devel/structeap__peer__config.html
+	 */
+	if (nm_setting_802_1x_get_engine (setting)) {
+		const char *pkcs11_engine_path = nm_setting_802_1x_get_pkcs11_engine_path (setting);
+		const char *pkcs11_module_path = nm_setting_802_1x_get_pkcs11_module_path (setting);
+
+		/* Add engine=1 and engine_id="pkcs11" to the network config */
+		if (!nm_supplicant_config_add_option (self, "engine", "1", -1, FALSE)) {
+			nm_log_warn (LOGD_SUPPLICANT,
+						 "Error adding engine=1 to WPA supplicant network "
+						 "config.");
+			return FALSE;
+		}
+		if (!add_string_val (self, "pkcs11", "engine_id", FALSE, FALSE)) {
+			nm_log_warn (LOGD_SUPPLICANT,
+						 "Error adding engine_id=\"pkcs11\" to WPA supplicant "
+						 "network config.");
+			return FALSE;
+		}
+
+		/* Add key_id, cert_id and ca_cert_id if they are set */
+		value = nm_setting_802_1x_get_key_id (setting);
+		if (value)
+			if (!add_string_val (self, value, "key_id", FALSE, FALSE)) {
+				nm_log_warn (LOGD_SUPPLICANT,
+							 "Error adding key_id=\"%s\" to WPA supplicant "
+							 "network config.",
+							 value);
+				return FALSE;
+			}
+		value = nm_setting_802_1x_get_cert_id (setting);
+		if (value)
+			if (!add_string_val (self, value, "cert_id", FALSE, FALSE)) {
+				nm_log_warn (LOGD_SUPPLICANT,
+							 "Error adding cert_id=\"%s\" to WPA supplicant "
+							 "network config.",
+							 value);
+				return FALSE;
+			}
+		value = nm_setting_802_1x_get_ca_cert_id (setting);
+		if (value)
+			if (!add_string_val (self, value, "ca_cert_id", FALSE, FALSE)) {
+				nm_log_warn (LOGD_SUPPLICANT,
+							 "Error adding ca_cert_id=\"%s\" to WPA "
+							 "supplicant network config.",
+							 value);
+				return FALSE;
+			}
+
+		/**
+		 * Pass through pkcs11_engine_path and pkcs11_module_path to WPA
+		 * supplicant interface config as these values are not part of the
+		 * network config but will be set directly via the D-Bus
+		 * Interface.SetPKCS11EngineAndModulePath method.
+		 */
+		if (pkcs11_engine_path && pkcs11_module_path) {
+			nm_supplicant_config_set_pkcs11_engine_path (self, pkcs11_engine_path);
+			nm_supplicant_config_set_pkcs11_module_path (self, pkcs11_module_path);
+		}
+	}
+
 	return TRUE;
 }
 
Index: NetworkManager-0.9.10.0/src/supplicant-manager/nm-supplicant-config.h
===================================================================
--- NetworkManager-0.9.10.0.orig/src/supplicant-manager/nm-supplicant-config.h	2014-07-04 02:44:13.000000000 +0200
+++ NetworkManager-0.9.10.0/src/supplicant-manager/nm-supplicant-config.h	2015-05-20 16:36:55.315611163 +0200
@@ -52,6 +52,16 @@
 
 NMSupplicantConfig *nm_supplicant_config_new (void);
 
+const char *nm_supplicant_config_get_pkcs11_engine_path (NMSupplicantConfig *self);
+
+void nm_supplicant_config_set_pkcs11_engine_path (NMSupplicantConfig *self,
+												  const char *pkcs11_engine_path);
+
+const char *nm_supplicant_config_get_pkcs11_module_path (NMSupplicantConfig *self);
+
+void nm_supplicant_config_set_pkcs11_module_path (NMSupplicantConfig *self,
+												  const char *pkcs11_module_path);
+
 guint32 nm_supplicant_config_get_ap_scan (NMSupplicantConfig *self);
 
 void nm_supplicant_config_set_ap_scan (NMSupplicantConfig *self,
Index: NetworkManager-0.9.10.0/src/supplicant-manager/nm-supplicant-interface.c
===================================================================
--- NetworkManager-0.9.10.0.orig/src/supplicant-manager/nm-supplicant-interface.c	2014-07-04 02:44:19.000000000 +0200
+++ NetworkManager-0.9.10.0/src/supplicant-manager/nm-supplicant-interface.c	2015-05-20 16:36:55.315611163 +0200
@@ -374,6 +374,92 @@
 	}
 }
 
+static void
+emit_error_helper (NMSupplicantInterface *self,
+				   GError *err);
+
+static void
+set_ap_scan_cb (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data);
+
+static gboolean
+call_set_ap_scan (NMSupplicantInterface *self)
+{
+	NMSupplicantInterfacePrivate *priv = NM_SUPPLICANT_INTERFACE_GET_PRIVATE (self);
+	DBusGProxyCall *call;
+	GValue value = G_VALUE_INIT;
+
+	g_value_init (&value, G_TYPE_UINT);
+	g_value_set_uint (&value, nm_supplicant_config_get_ap_scan (priv->cfg));
+
+	call = dbus_g_proxy_begin_call (priv->props_proxy, "Set",
+									set_ap_scan_cb,
+									self,
+									NULL,
+									G_TYPE_STRING, WPAS_DBUS_IFACE_INTERFACE,
+									G_TYPE_STRING, "ApScan",
+									G_TYPE_VALUE, &value,
+									G_TYPE_INVALID);
+	nm_call_store_add (priv->assoc_pcalls, priv->props_proxy, call);
+
+	g_value_unset (&value);
+
+	return call != NULL;
+}
+
+static void
+set_pkcs11_engine_and_module_path_cb (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
+{
+	NMSupplicantInterface *self = NM_SUPPLICANT_INTERFACE (user_data);
+	NMSupplicantInterfacePrivate *priv = NM_SUPPLICANT_INTERFACE_GET_PRIVATE (self);
+	GError *err = NULL;
+
+	if (!dbus_g_proxy_end_call (proxy, call_id, &err, G_TYPE_INVALID)) {
+		nm_log_warn (LOGD_SUPPLICANT,
+					 "Couldn't send PKCS #11 engine and module path: %s.",
+					 err->message);
+		emit_error_helper (self, err);
+		g_error_free (err);
+		return;
+	}
+
+	nm_log_info (LOGD_SUPPLICANT,
+				 "Config: set PKCS #11 engine path to: %s",
+				 nm_supplicant_config_get_pkcs11_engine_path (priv->cfg));
+	nm_log_info (LOGD_SUPPLICANT,
+				 "Config: set PKCS #11 module path to: %s",
+				 nm_supplicant_config_get_pkcs11_module_path (priv->cfg));
+
+	/* Continue with setting ApScan */
+	call_set_ap_scan (self);
+}
+
+static gboolean
+call_set_pkcs11_engine_and_module_path (NMSupplicantInterface *self)
+{
+	NMSupplicantInterfacePrivate *priv = NM_SUPPLICANT_INTERFACE_GET_PRIVATE (self);
+	DBusGProxyCall *call;
+	const char *pkcs11_engine_path = nm_supplicant_config_get_pkcs11_engine_path (priv->cfg);
+	const char *pkcs11_module_path = nm_supplicant_config_get_pkcs11_module_path (priv->cfg);
+
+	if (!(pkcs11_engine_path && pkcs11_module_path))
+		/**
+		 * No PKCS #11 engine and module path to set. Skip the
+		 * SetPKCS11EngineAndModulePath D-Bus method call and
+		 * continue with setting the ApScan D-Bus property.
+		 */
+		return call_set_ap_scan (self);
+
+	call = dbus_g_proxy_begin_call (priv->iface_proxy, "SetPKCS11EngineAndModulePath",
+									set_pkcs11_engine_and_module_path_cb,
+									self,
+									NULL,
+									G_TYPE_STRING, pkcs11_engine_path,
+									G_TYPE_STRING, pkcs11_module_path,
+									G_TYPE_INVALID);
+	nm_call_store_add (priv->assoc_pcalls, priv->props_proxy, call);
+	return call != NULL;
+}
+
 gboolean
 nm_supplicant_interface_get_scanning (NMSupplicantInterface *self)
 {
@@ -1126,8 +1212,6 @@
                                     NMSupplicantConfig *cfg)
 {
 	NMSupplicantInterfacePrivate *priv;
-	DBusGProxyCall *call;
-	GValue value = G_VALUE_INIT;
 
 	g_return_val_if_fail (NM_IS_SUPPLICANT_INTERFACE (self), FALSE);
 
@@ -1152,21 +1236,7 @@
 
 	g_object_ref (priv->cfg);
 
-	g_value_init (&value, G_TYPE_UINT);
-	g_value_set_uint (&value, nm_supplicant_config_get_ap_scan (priv->cfg));
-
-	call = dbus_g_proxy_begin_call (priv->props_proxy, "Set",
-	                                set_ap_scan_cb,
-	                                self,
-	                                NULL,
-	                                G_TYPE_STRING, WPAS_DBUS_IFACE_INTERFACE,
-	                                G_TYPE_STRING, "ApScan",
-	                                G_TYPE_VALUE, &value,
-	                                G_TYPE_INVALID);
-	nm_call_store_add (priv->assoc_pcalls, priv->props_proxy, call);
-
-	g_value_unset (&value);
-	return call != NULL;
+	return call_set_pkcs11_engine_and_module_path (self);
 }
 
 static void
Index: NetworkManager-0.9.10.0/src/supplicant-manager/nm-supplicant-settings-verify.c
===================================================================
--- NetworkManager-0.9.10.0.orig/src/supplicant-manager/nm-supplicant-settings-verify.c	2014-07-04 02:44:13.000000000 +0200
+++ NetworkManager-0.9.10.0/src/supplicant-manager/nm-supplicant-settings-verify.c	2015-05-20 16:36:55.315611163 +0200
@@ -86,6 +86,7 @@
                                    "auth=MD5", "auth=TLS", "autheap=MD5",
                                    "autheap=MSCHAPV2", "autheap=OTP",
                                    "autheap=GTC", "autheap=TLS", NULL };
+const char * engine_id_allowed[] = { "pkcs11", NULL };
 
 static const struct Opt opt_table[] = {
 	{ "ssid",               TYPE_BYTES,   0, 32,FALSE,  NULL },
@@ -131,8 +132,10 @@
 	{ "eappsk",             TYPE_BYTES,   0, 0, FALSE,  NULL },
 	{ "pac_file",           TYPE_BYTES,   0, 0, FALSE,  NULL },
 	{ "engine",             TYPE_INT,     0, 1, FALSE,  NULL },
-	{ "engine_id",          TYPE_BYTES,   0, 0, FALSE,  NULL },
+	{ "engine_id",          TYPE_KEYWORD, 0, 0, FALSE,  engine_id_allowed },
 	{ "key_id",             TYPE_BYTES,   0, 0, FALSE,  NULL },
+	{ "cert_id",            TYPE_BYTES,   0, 0, FALSE,  NULL },
+	{ "ca_cert_id",         TYPE_BYTES,   0, 0, FALSE,  NULL },
 	{ "fragment_size",      TYPE_INT,     1, 2000, FALSE,  NULL },
 	{ "proactive_key_caching", TYPE_INT,  0, 1, FALSE,  NULL },
 	{ "bgscan",             TYPE_BYTES,   0, 0, FALSE,  NULL },
